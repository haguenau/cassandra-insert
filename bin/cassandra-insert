#! /usr/bin/perl -w
use strict;
require 5.10.0;
use Cassandra::Client;
use Getopt::Long;
use Time::HiRes qw(time sleep);
use JSON;
use FindBin qw($RealBin);
#use lib $RealBin . '/../lib';
#use BinaryEncode qw(:all);

## Parse config file
my $fconf = $RealBin . '/../conf/cassandra-insert.json';
open(FCONF, $fconf)
  or die "Couldn't open \`$fconf' for reading: $!";
my $conf;
{
    local $/ = undef;
    $conf = from_json <FCONF>;
}
close FCONF;

my @seed_hosts = @{$conf->{nodes} // []};
my $db = $conf->{db};

## Parse command line (overrides conf)
my $table;
my $ttl = 86400;

my $throttle_interval = 100;    # Adjust for pacing after this many inserts
my $throttle_wps = 1000;        # Set writes per second limit
exit 1 unless GetOptions
  (
   'nodes=s' => sub { @seed_hosts = split /,/, $_[1]; },
   'db=s' => \$db,
   'table=s' => \$table,
   'ttl=s' => \$ttl,
   'throttle-wps=s' => \$throttle_wps,
  );

my %mustset =
  (
   table => \$table,
   db => \$db,
  );

my $ok = 1;
for my $k (keys %mustset) {
    unless (defined ${$mustset{$k}}) {
        warn "Error: parameter \`$k' is unset.\n";
        $ok = 0;
    }
}
exit 1 unless $ok;

my $time_start = time;
sub throttle_sleep($$) {
    my ($wps, $writes_completed) = @_;
    return unless defined $wps or $wps <= 0;

    my $target_duration = $writes_completed / $wps;
    my $target_time = $time_start + $target_duration;
    my $now = time;

    if ($now < $target_time) {
        my $sleep_seconds = $target_time - $now;
        printf STDERR "Sleep %.2f to respect throttling.\n", $sleep_seconds;
        sleep $sleep_seconds;
    }

}

## do_it
my $cass = Cassandra::Client->new
  (
   contact_points => \@seed_hosts,
   keyspace => $db,
  );

$cass->connect;

my $query = sprintf
  'INSERT INTO "%s" (key, column1, column2, value) VALUES (?, ?, ?, ?)',
  $table;
my $ttl_query = ' USING TTL ?';

if (defined $ttl) {
    $query .= sprintf $ttl_query, $ttl;
}

my ($recs_in, $recs_out, $bad_recs, $write_failures) = (0, 0, 0, 0);
while (<STDIN>) {
    ++$recs_in;
    my @values = split /\t/;
    if (@values != 4) {
        ++$bad_recs;
        next;
    }
    push @values, $ttl if defined $ttl;

    my $ok = eval { $cass->execute($query, \@values); };

    if ($ok) {
        ++$recs_out;
    } else {
        ++$write_failures;
        printf STDERR "FAIL: %s\n", join ', ', $@;
    }

    if (($recs_out % $throttle_interval) == 0) {
        throttle_sleep $throttle_wps, $recs_out;
    }
}

printf "i:%d o:%d b:%d f:%d\n", $recs_in, $recs_out, $bad_recs, $write_failures;
