#! /usr/bin/perl -w
use strict;
require 5.10.0;
use Cassandra::Client;
use Getopt::Long;
use JSON;
use FindBin qw($RealBin);
#use lib $RealBin . '/../lib';
#use BinaryEncode qw(:all);

## Parse config file
my $fconf = $RealBin . '/../conf/cassandra-insert.json';
open(FCONF, $fconf)
  or die "Couldn't open \`$fconf' for reading: $!";
my $conf;
{
    local $/ = undef;
    $conf = from_json <FCONF>;
}
close FCONF;

my @seed_hosts = @{$conf->{nodes} // []};
my $db = $conf->{db};

## Parse command line (overrides conf)
my $table;
my $ttl = 86400;
my $maxwps = undef;
exit 1 unless GetOptions
  (
   'nodes=s' => sub { @seed_hosts = split /,/, $_[1]; },
   'db=s' => \$db,
   'table=s' => \$table,
   'ttl=s' => \$ttl,
   'throttle-wps=s' => \$maxwps,
  );

my %mustset =
  (
   table => \$table,
   db => \$db,
  );

my $ok = 1;
for my $k (keys %mustset) {
    unless (defined ${$mustset{$k}}) {
        warn "Error: parameter \`$k' is unset.\n";
        $ok = 0;
    }
}
exit 1 unless $ok;

## do_it
my $cass = Cassandra::Client->new
  (
   contact_points => \@seed_hosts,
   keyspace => $db,
  );

$cass->connect;

my $query =
  'INSERT INTO users (key, column1, column2, value) VALUES (?, ?, ?, ?)';
my $ttl_query = ' USING TTL ?';

if (defined $ttl) {
    $query .= sprintf $ttl_query, $ttl;
}

my ($recs_in, $recs_out, $bad_recs, $write_failures) = (0, 0, 0, 0);
while (<STDIN>) {
    ++$recs_in;
    my @values = split /\t/;
    if (@values != 4) {
        ++$bad_recs;
        next;
    }
    push @values, $ttl if defined $ttl;

    my $ok = eval { $cass->execute($query, \@values); };

    if ($ok) {
        ++$recs_out;
    } else {
        ++$write_failures;
        printf STDERR "FAIL: %s\n", join ', ', $@;
    }
}

printf "i:%d o:%d b:%d f:%d\n", $recs_in, $recs_out, $bad_recs, $write_failures;
