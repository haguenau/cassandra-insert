#! /usr/bin/perl -w
use strict;
require 5.10.0;
use Cassandra::Client;
use Getopt::Long;
use Time::HiRes qw(time sleep);
use JSON;
use FindBin qw($RealBin);
use lib $RealBin . '/../lib';
use BinaryCodec qw(:all);

## Parse config file
my $fconf = $RealBin . '/../conf/cassandra-insert.json';
open(FCONF, $fconf)
  or die "Couldn't open \`$fconf' for reading: $!";
my $conf;
{
    local $/ = undef;
    $conf = from_json <FCONF>;
}
close FCONF;

my @seed_hosts = @{$conf->{nodes} // []};
my $db = $conf->{db};

## Parse command line (overrides conf)
my $table;
my $ttl = 86400;

my $throttle_interval = 100;    # Adjust for pacing after this many inserts
my $throttle_wps = 1000;        # Set writes per second limit

my $def_constants;
my $def_types;
exit 1 unless GetOptions
  (
   'nodes=s' => sub { @seed_hosts = split /,/, $_[1]; },
   'db=s' => \$db,
   'table=s' => \$table,
   'ttl=s' => \$ttl,
   'throttle-wps=s' => \$throttle_wps,
   'const=s' => \$def_constants,
   'header=s' => \$def_types,
  );

my %mustset =
  (
   const => \$def_constants,
   db => \$db,
   header => \$def_types,
   table => \$table,
  );

my $ok = 1;
for my $k (keys %mustset) {
    unless (defined ${$mustset{$k}}) {
        warn "Error: parameter \`$k' is unset.\n";
        $ok = 0;
    }
}
exit 1 unless $ok;

sub identity($) { return shift; }

my %converters =
  (
   'auto' => \&identity,
   'delta-varint-list' => \&BinaryCodec::delta_varint_list_encode,
  );
my %keys = map { $_ => 1 } qw(key column1 column2 value);

sub check_get_converter($) {
    my $type = shift;
    my $converter = $converters{$type};

    die "No converter for type \`$type'" unless defined $converter;
    return $converter;
}

sub check_key_definable($) {
    my $key = shift;
    die "Bad key \`$key'" unless defined $keys{$key};

    ## TODO: also check for redefinition attempts.
}


## Parse constants
# fmt: <id>:<type>=<value>{,<id>:<type>=<value>}
my %consts = ();
my @conststrs = split /,/, $def_constants;
for my $constdef (@conststrs) {
    my ($k, $t, $v) = $constdef =~ /^([a-z0-9-]+):([a-z0-9-]+)=(.*)$/;
    die "Bad constant definition string \`$constdef'" unless defined $v;

    my $converter = check_get_converter $t;
    my $blob = $converter->($v);

    use Data::Dumper; printf "`%s' => %s\n", $constdef, Dumper(\$blob);
    $consts{$k} = $blob;
}

## Parse header
# fmt: <id>:<type>{,<id>:<type>}
my @headers = ();
my @headstrs = split /,/, $def_types;
for my $typedef (@headstrs) {
    my ($k, $t) = $typedef =~ /^([a-z0-9-]+):([a-z0-9-]+)$/;
    die "Bad type declaration string \`$typedef'" unless defined $t;

    my $converter = check_get_converter $t;
    push @headers, { key => $k, conver => $converter };
}

## TODO: check that keys of @consts and @headers partition those of %keys

my $time_start = time;
sub throttle_sleep($$) {
    my ($wps, $writes_completed) = @_;
    return unless defined $wps or $wps <= 0;

    my $target_duration = $writes_completed / $wps;
    my $target_time = $time_start + $target_duration;
    my $now = time;

    if ($now < $target_time) {
        my $sleep_seconds = $target_time - $now;
        printf STDERR "Sleep %.2f to respect throttling.\n", $sleep_seconds;
        sleep $sleep_seconds;
    }

}

## do_it
my $cass = Cassandra::Client->new
  (
   contact_points => \@seed_hosts,
   keyspace => $db,
  );

$cass->connect;

my $query = sprintf
  'INSERT INTO "%s" (key, column1, column2, value) VALUES (?, ?, ?, ?)',
  $table;
my $ttl_query = ' USING TTL ?';

if (defined $ttl) {
    $query .= sprintf $ttl_query, $ttl;
}

my ($recs_in, $recs_out, $bad_recs, $write_failures) = (0, 0, 0, 0);
while (<STDIN>) {
    ++$recs_in;
    my @values = split /\t/;
    if (@values != @headers) {
        ++$bad_recs;
        next;
    }
    push @values, $ttl if defined $ttl;

    my $ok = eval { $cass->execute($query, \@values); };

    if ($ok) {
        ++$recs_out;
    } else {
        ++$write_failures;
        printf STDERR "FAIL: %s\n", join ', ', $@;
    }

    if (($recs_out % $throttle_interval) == 0) {
        throttle_sleep $throttle_wps, $recs_out;
    }
}

printf "i:%d o:%d b:%d f:%d\n", $recs_in, $recs_out, $bad_recs, $write_failures;
